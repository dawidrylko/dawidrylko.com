---
title: Memoizacja âš¡ï¸ Harry Potter i MyÅ›lodsiewnia
description: Zanurz siÄ™ w fascynujÄ…cy Å›wiat memoizacji. Techniki programistycznej, ktÃ³ra zmienia sposÃ³b, w jaki TwÃ³j kod przetwarza informacje! WyobraÅº sobie, Å¼e TwÃ³j program potrafi "zapamiÄ™tywaÄ‡" i bÅ‚yskawicznie przywoÅ‚ywaÄ‡ wyniki skomplikowanych obliczeÅ„, niczym MyÅ›lodsiewnia Dumbledore'a przechowujÄ…ca wspomnienia.
date: 2025-07-29T12:00:00.000Z
featuredImg: ./Dumbledore_przy_komputerze.png
featuredImgAlt: "Obraz przedstawia Dumbledore'a, z dÅ‚ugÄ… siwÄ… brodÄ… i okularami, siedzÄ…cego przy biurku i uÅ¼ywajÄ…cego komputera jako MyÅ›lodsiewni. Z jego gÅ‚owy wydobywa siÄ™ Å›wietlista niÄ‡ myÅ›li, ktÃ³ra trafia do ekranu komputera. CaÅ‚oÅ›Ä‡ utrzymana jest w mrocznym klimacie fantasy, w stylu komiksÃ³w Stana Lee. Wygenerowana przez AI."
tags: ['math', 'datascience', 'typescript']
---

WyobraÅº sobie, Å¼e jesteÅ› sÄ™dziwym Albusem Dumbledorem. KaÅ¼dÄ… wolnÄ… chwilÄ™ poÅ›wiÄ™casz analizie swoich dawnych decyzji. NajwiÄ™cej uwagi, rzecz jasna, kierujesz ku Tomowi Riddle'owi. KaÅ¼de wspomnienie, kaÅ¼dy detal, kaÅ¼da wymiana zdaÅ„. Wszystko moÅ¼e okazaÄ‡ siÄ™ kluczem do pokonania zÅ‚a.

DÄ…Å¼ysz do peÅ‚nego zrozumienia, nawet jeÅ›li pozornie nic nie wskazuje na nowy trop. Robisz to wieczÃ³r po wieczorze, dzieÅ„ po dniu. Nie chcesz jednak za kaÅ¼dym razem zaczynaÄ‡ od poczÄ…tku, przeÅ¼ywaÄ‡ tych samych, czÄ™sto bolesnych chwil. Nie chcesz znÃ³w i znÃ³w dochodziÄ‡ do tych samych wnioskÃ³w.

Chcesz iÅ›Ä‡ dalej. Ale gubisz siÄ™ w natÅ‚oku myÅ›li. Nie pamiÄ™tasz, czy juÅ¼ to analizowaÅ‚eÅ›? A moÅ¼e tylko wydaje ci siÄ™ znajome?

## MyÅ›lodsiewnia

Z pomocÄ… przychodzi **MyÅ›lodsiewnia** (ang. _Pensieve_). To magiczna, kamienna misa, w ktÃ³rej moÅ¼esz przechowywaÄ‡ i przeglÄ…daÄ‡ swoje wspomnienia.

WyciÄ…gniÄ™cie wspomnienia z gÅ‚owy, niczym srebrnej nitki spÅ‚ywajÄ…cej po rÃ³Å¼dÅ¼ce, trwa chwilÄ™ i nie wymaga wysiÅ‚ku. Zawsze moÅ¼esz do niego wrÃ³ciÄ‡. MoÅ¼esz je ponownie przeanalizowaÄ‡, bez potrzeby przetwarzania go od nowa w swoim umyÅ›le. Wspomnienia sÄ… bezpieczne i uporzÄ…dkowane, gotowe do uÅ¼ycia, kiedy tylko zechcesz.

DziÄ™ki temu moÅ¼esz przesuwaÄ‡ granicÄ™ zrozumienia coraz dalej. Nie tracisz czasu i energii na rzeczy, ktÃ³re juÅ¼ raz przemyÅ›laÅ‚eÅ›.

W programowaniu mamy dokÅ‚adnie ten sam problem, ktÃ³ry drÄ™czyÅ‚ Dumbledore'a. Funkcja, ktÃ³ra analizuje dane lub wykonuje kosztowne obliczenia, czÄ™sto nie musi byÄ‡ uruchamiana wielokrotnie dla tych samych danych wejÅ›ciowych. Wynik bÄ™dzie przecieÅ¼ identyczny.

Zamiast wiÄ™c liczyÄ‡ wszystko od poczÄ…tku, moÅ¼emy siÄ™gnÄ…Ä‡ po technikÄ™, ktÃ³rÄ… na czeÅ›Ä‡ pamiÄ™tania nazwano **memoizacjÄ…**.

## Memoizacja funkcyjna (_functional memoization_)

**Memoizacja funkcyjna** to technika optymalizacyjna, ktÃ³ra polega na zapamiÄ™tywaniu wynikÃ³w wywoÅ‚aÅ„ funkcji dla okreÅ›lonych argumentÃ³w. DziaÅ‚a jak osobista MyÅ›lodsiewnia dla funkcji. Gdy funkcja jest wywoÅ‚ywana ponownie z tymi samymi argumentami, jej wynik jest natychmiast zwracany z pamiÄ™ci podrÄ™cznej (_cache_), zamiast byÄ‡ ponownie obliczany. Unikamy w ten sposÃ³b wielokrotnego wykonywania tych samych, czÄ™sto kosztownych operacji, co ma bezpoÅ›redni wpÅ‚yw na przyspieszenie dziaÅ‚ania programu.

![Obraz w stylu komiksowym, przypominajÄ…cym prace Stana Lee, przedstawia HermionÄ™ Granger siedzÄ…cÄ… przy drewnianym biurku. Ma na sobie szatÄ™ Hogwartu i intensywny wyraz twarzy, skupiony na otwartej ksiÄ™dze, do ktÃ³rej pisze Å›wiecÄ…cym piÃ³rem. Biurko jest zastawione idealnie poukÅ‚adanymi stosami grubych ksiÄ…g i podrÄ™cznikÃ³w po obu stronach. Na pierwszym planie, na tacy, stojÄ… symetrycznie uÅ‚oÅ¼one fiolki i zlewki z kolorowymi eliksirami. CaÅ‚oÅ›Ä‡ utrzymana jest w mrocznym, akademickim klimacie, z dramatycznym oÅ›wietleniem. Wygenerowana przez AI.](./Hermiona_przy_biurku.png)
Podobnie jak potÄ™Å¼ne zaklÄ™cie, funkcja poddana memoizacji musi speÅ‚niaÄ‡ dwa kluczowe warunki:

1. **Musi byÄ‡ czysta i deterministyczna**: dla tych samych argumentÃ³w zawsze musi zwracaÄ‡ ten sam wynik.
1. **Nie moÅ¼e mieÄ‡ efektÃ³w ubocznych** (_side effects_): jej dziaÅ‚anie nie moÅ¼e zmieniaÄ‡ niczego poza niÄ… samÄ….

### PrzykÅ‚ad: Rzucanie zaklÄ™cia `Memoize`

Oto jak moÅ¼emy stworzyÄ‡ wÅ‚asne zaklÄ™cie `memoize` w TypeScript, ktÃ³re opakuje dowolnÄ… funkcjÄ™ i da jej moc pamiÄ™tania.

```typescript
const memoize = <F extends (...args: any[]) => any>(fn: F): F => {
  // Nasza MyÅ›lodsiewnia do przechowywania wspomnieÅ„
  const cache = new Map<string, ReturnType<F>>();

  return ((...args: any[]) => {
    // Tworzymy unikalny klucz dla kaÅ¼dego zestawu argumentÃ³w
    const key = JSON.stringify(args);

    // Sprawdzamy, czy juÅ¼ analizowaliÅ›my to wspomnienie
    if (cache.has(key)) {
      // JeÅ›li tak, zwracamy wynik z MyÅ›lodsiewni
      return cache.get(key)!;
    }

    // JeÅ›li nie, wykonujemy kosztowne obliczenie
    const result = fn(...args);
    // I zapisujemy je w MyÅ›lodsiewni na przyszÅ‚oÅ›Ä‡
    cache.set(key, result);
    return result;
  }) as F;
};
```

W ramach testÃ³w uÅ¼yjemy tej funkcji do memoizacji klasycznego, rekurencyjnego algorytmu na ciÄ…g Fibonacciego. Jest on znany z tego, Å¼e bez optymalizacji jego zÅ‚oÅ¼onoÅ›Ä‡ czasowa roÅ›nie wykÅ‚adniczo, niczym liczba diabeÅ‚kÃ³w kornwalijskich wypuszczonych w klasie.

```typescript
const test = () => {
  const fib = (n: number): number => (n < 2 ? n : fib(n - 1) + fib(n - 2));
  const fibMemoized = memoize(fib);

  const results: any[] = [];

  const measure = (label: string, fn: () => any, expectCached: boolean = false) => {
    const start = performance.now();
    const result = fn();
    const time = (performance.now() - start).toFixed(2);
    results.push({ call: label, result, time: `${time}ms`, cached: expectCached ? `âœ… Yes` : `âŒ No` });
  };

  measure(`fib(35) normal`, () => fib(35));
  measure(`fib(35) memoized 1st`, () => fibMemoized(35));
  measure(`fib(35) memoized 2nd`, () => fibMemoized(35), true);
  measure(`fib(30) memoized`, () => fibMemoized(30), true);
  measure(`fib(40) normal`, () => fib(40));
  measure(`fib(40) memoized 1st`, () => fibMemoized(40));
  measure(`fib(40) memoized 2nd`, () => fibMemoized(40), true);

  console.table(results);
};

test();
```

Wyniki dziaÅ‚ania tego kodu pokazujÄ…, jak potÄ™Å¼na jest memoizacja. Pierwsze wywoÅ‚anie `fibMemoized` jest wolne, poniewaÅ¼ musi wykonaÄ‡ wszystkie obliczenia. KaÅ¼de kolejne dla tego samego argumentu jest juÅ¼ bÅ‚yskawiczne. Wynik jest pobierany prosto z MyÅ›lodsiewni.

![Memoizacja funkcyjna - wyniki](./1.Memoizacja-funkcyjna-wyniki.png)

## Memoizacja strukturalna (_structural memoization_)

**Memoizacja strukturalna** to technika, w ktÃ³rej zamiast duplikowaÄ‡ identyczne struktury danych, wspÃ³Å‚dzielimy jednÄ…, kanonicznÄ… instancjÄ™. Jest to odpowiednik rozpoznawania przez Ministerstwo Magii, Å¼e dwie rÃ³Å¼dÅ¼ki, mimo Å¼e sÄ… oddzielnymi przedmiotami, majÄ… _identycznÄ…_ budowÄ™ (np. 11 cali, ostrokrzew, piÃ³ro feniksa) i mogÄ… byÄ‡ w katalogu reprezentowane przez ten sam wzorzec.

Technika ta, czÄ™sto nazywana _hash-consing_, unika tworzenia nadmiarowych kopii obiektÃ³w i przyspiesza ich porÃ³wnywanie. Zamiast sprawdzaÄ‡ caÅ‚Ä… strukturÄ™ pole po polu, wystarczy porÃ³wnaÄ‡ referencje.

### PrzykÅ‚ad: Katalogowanie magicznych wÄ™zÅ‚Ã³w

WyobraÅºmy sobie, Å¼e budujemy drzewo genealogiczne czarodziejÃ³w. Wiele osÃ³b bÄ™dzie miaÅ‚o te same, proste cechy. Zamiast tworzyÄ‡ nowy obiekt dla kaÅ¼dej cechy, moÅ¼emy je wspÃ³Å‚dzieliÄ‡.

```typescript
// Definicja klasy reprezentujÄ…cej postaÄ‡
class Character {
  constructor(
    public readonly value: string,
    public readonly children: Character[] = [],
  ) {}
}

// Katalog postaci, ktÃ³ry bÄ™dzie przechowywaÅ‚ wspÃ³Å‚dzielone instancje
const characterCache = new Map<string, Character>();

const createSharedCharacter = (value: string, children: Character[] = []): Character => {
  // Tworzymy unikalny klucz na podstawie wartoÅ›ci i dzieci
  const key = `${value}:${children.map(c => c.value).join(`,`)}`;

  if (characterCache.has(key)) {
    console.log(`â™»ï¸ Sharing character: ${value}`);
    return characterCache.get(key)!;
  }

  console.log(`âœ¨ Creating new character: ${value}`);
  const newCharacter = new Character(value, children);
  characterCache.set(key, newCharacter);
  return newCharacter;
};

// PrzykÅ‚adowe postacie
const pureBlood = createSharedCharacter(`Pure blood`);
const halfBlood = createSharedCharacter(`Half blood`);
const harry = createSharedCharacter(`Harry`, [halfBlood]);
const draco = createSharedCharacter(`Draco`, [pureBlood]);
const dracoTwin = createSharedCharacter(`Draco`, [pureBlood]); // To samo co Draco, ale z tej samej instancji!

console.log(harry !== draco); // true, rÃ³Å¼ne obiekty
console.log(draco === dracoTwin); // true, ten sam obiekt wspÃ³Å‚dzielony!
```

## Z gÃ³ry na dÃ³Å‚ (_top-down_) vs. z doÅ‚u do gÃ³ry (_bottom-up_)

Problem obliczeniowy moÅ¼na rozwiÄ…zywaÄ‡ na dwa sposoby, niczym naukÄ™ skomplikowanego zaklÄ™cia.

- **Z gÃ³ry na dÃ³Å‚ (_Top-down_ z MemoizacjÄ…)**: Zaczynasz od gÅ‚Ã³wnego problemu i rekurencyjnie dzielisz go na mniejsze. Wyniki podproblemÃ³w zapisujesz w MyÅ›lodsiewni, by do nich nie wracaÄ‡. To jak Dumbledore, ktÃ³ry stawia sobie cel "zniszczyÄ‡ Horkruksy" i rozbija go na zadania: "znaleÅºÄ‡ dziennik", "znaleÅºÄ‡ pierÅ›cieÅ„" itd., zapamiÄ™tujÄ…c postÄ™py.
- **Z doÅ‚u do gÃ³ry (_Bottom-up_ z TabulacjÄ…)**: Zaczynasz od najprostszych, bazowych przypadkÃ³w i iteracyjnie budujesz rozwiÄ…zanie coraz wiÄ™kszych problemÃ³w, aÅ¼ dojdziesz do tego wÅ‚aÅ›ciwego. To jak uczeÅ„ w Hogwarcie, ktÃ³ry najpierw opanowuje "Wingardium Leviosa", potem "Accio", a dopiero na koÅ„cu prÃ³buje rzuciÄ‡ Patronusa. Budujesz fundamenty, zanim wzniesiesz wieÅ¼Ä™.

![Top-down vs Bottom-up](./2.top-down-vs-bottom-up.png)

PodejÅ›cie _top-down_ jest czÄ™sto bardziej intuicyjne, ale moÅ¼e prowadziÄ‡ do gÅ‚Ä™bokiej rekurencji. _Bottom-up_ bywa wydajniejsze, bo unika narzutu rekurencji i od razu buduje caÅ‚Ä… tablicÄ™ potrzebnych wynikÃ³w.

### PrzykÅ‚ad: Dwa podejÅ›cia do Fibonacciego

```typescript
// PodejÅ›cie z gÃ³ry na dÃ³Å‚ (Top-down) - Rekurencja z memoizacjÄ…
const fibTopDown = (n: number, memo: Record<number, number> = {}): number => {
  if (n in memo) return memo[n];
  if (n < 2) return n;

  memo[n] = fibTopDown(n - 1, memo) + fibTopDown(n - 2, memo);
  return memo[n];
};

console.log(`Top-down fib(10): ${fibTopDown(10)}`); // Wynik: 55

// PodejÅ›cie z doÅ‚u do gÃ³ry (Bottom-up) - Tabulacja
const fibBottomUp = (n: number): number => {
  if (n < 2) return n;

  const table = [0, 1];

  for (let i = 2; i <= n; i++) {
    table[i] = table[i - 1] + table[i - 2];
  }

  return table[n];
};

console.log(`Bottom-up fib(10): ${fibBottomUp(10)}`); // Wynik: 55
```

## Leniwa memoizacja (_lazy memoization_)

**Leniwa memoizacja** to technika, ktÃ³ra Å‚Ä…czy memoizacjÄ™ z **leniwÄ… ewaluacjÄ…**. Obliczenie wartoÅ›ci jest odraczane do momentu, gdy wynik jest faktycznie potrzebny. Dopiero wtedy jest on obliczany i zapamiÄ™tywany.

To dziaÅ‚a jak Mapa HuncwotÃ³w. Sama w sobie jest tylko kawaÅ‚kiem pergaminu. Ujawnienie mapy Hogwartu nastÄ™puje dopiero po wypowiedzeniu zaklÄ™cia "UroczyÅ›cie przysiÄ™gam, Å¼e knujÄ™ coÅ› niedobrego". Po pierwszym uÅ¼yciu treÅ›Ä‡ jest juÅ¼ znana i gotowa do wglÄ…du.

### PrzykÅ‚ad: Leniwe pozyskiwanie wiedzy

MoÅ¼emy zaimplementowaÄ‡ to na dwa sposoby:

```typescript
// 1. Z elementem zastÄ™pczym (placeholder)
class LazyValue<T> {
  private _value?: T;
  private hasBeenCalculated = false;

  constructor(private readonly calculation: () => T) {}

  public get value(): T {
    if (!this.hasBeenCalculated) {
      console.log(`ğŸ“œ Activating the Marauder's Map for the first time...`);
      this._value = this.calculation();
      this.hasBeenCalculated = true;
    }
    return this._value!;
  }
}

const mapContent = new LazyValue(() => `Hogwarts map with all secret passages`);
console.log(`The parchment lies closed.`);
console.log(mapContent.value); // Pierwsze uÅ¼ycie - obliczenie
console.log(mapContent.value); // Drugie uÅ¼ycie - natychmiastowy zwrot

// 2. Z leniwÄ… funkcjÄ… (thunk)
const createLazyFunction = <T>(calculation: () => T): (() => T) => {
  let value: T;
  let isCalculated = false;

  return () => {
    if (!isCalculated) {
      console.log(`ğŸ”® Looking into the crystal ball for the first time...`);
      value = calculation();
      isCalculated = true;
    }
    return value;
  };
};

const getProphecy = createLazyFunction(() => `THE ONE WITH THE POWER TO VANQUISH THE DARK LORD APPROACHES...`);
console.log(`The prophecy awaits discovery.`);
console.log(getProphecy()); // Pierwsze uÅ¼ycie - obliczenie
console.log(getProphecy()); // Drugie uÅ¼ycie - natychmiastowy zwrot
```

## Demo: Dumbledore's Pensieve

PoniÅ¼szy interaktywny przykÅ‚ad to nasza wÅ‚asna MyÅ›lodsiewnia w akcji. KaÅ¼de klikniÄ™cie w nazwÄ™ Horkruksa jest jak zanurzenie gÅ‚owy w magicznej misie, by przeanalizowaÄ‡ zwiÄ…zane z nim, mroczne wspomnienie.

Aplikacja celowo symuluje kosztowne "wydobywanie wspomnienia", ktÃ³re za pierwszym razem trwa od 2 do 5 sekund. Kiedy jednak wspomnienie zostanie juÅ¼ raz "przeanalizowane", trafia do pamiÄ™ci podrÄ™cznej (_cache_). KaÅ¼de kolejne klikniÄ™cie w ten sam Horkruks zwrÃ³ci wynik **natychmiast**, czerpiÄ…c go prosto z naszej cyfrowej MyÅ›lodsiewni.

Obserwuj logi, aby zobaczyÄ‡, kiedy aplikacja wykonuje ciÄ™Å¼kÄ… pracÄ™ (`ğŸ” Extracting memories...`), a kiedy bÅ‚yskawicznie korzysta z zapamiÄ™tanego wyniku (`âš¡ Retrieved from memory cache`).

{/* Musi byÄ‡ odstÄ™p pomiÄ™dzy importem a komponentem */}
import MemoizationDemo from '../../../src/demo/memoization-demo.tsx';

<MemoizationDemo />

## Podsumowanie

Memoizacja to potÄ™Å¼na technika pozwalajÄ…ca efektywnie zarzÄ…dzaÄ‡ czasem i zasobami w programowaniu. Zamiast w kÃ³Å‚ko przetwarzaÄ‡ te same dane, moÅ¼emy zapisaÄ‡ wynik i siÄ™gaÄ‡ po niego w mgnieniu oka. DziÄ™ki temu nasze aplikacje stajÄ… siÄ™ szybsze, a my moÅ¼emy skupiÄ‡ siÄ™ na nowych wyzwaniach. Zalety memoizacji to:

- **Przyspiesza dziaÅ‚anie aplikacji**: zwÅ‚aszcza w operacjach na UI (np. React), przy przetwarzaniu danych i w Å¼Ä…daniach do API.
- **Upraszcza kod**: eliminujÄ…c potrzebÄ™ rÄ™cznego zarzÄ…dzania wynikami powtarzalnych obliczeÅ„.
- **OszczÄ™dza zasoby**: redukujÄ…c liczbÄ™ kosztownych operacji, jak skomplikowane algorytmy czy zapytania do bazy danych.

Jednak, jak kaÅ¼da magia, wymaga ostroÅ¼noÅ›ci. Jej naduÅ¼ywanie moÅ¼e mieÄ‡ skutki uboczne. Wady memoizacji to:

- **ZwiÄ™kszone zuÅ¼ycie pamiÄ™ci**: przechowywanie wielu wynikÃ³w w _cache_ moÅ¼e prowadziÄ‡ do wyciekÃ³w pamiÄ™ci, jeÅ›li nie zarzÄ…dzamy nim wÅ‚aÅ›ciwie.
- **Dodatkowa zÅ‚oÅ¼onoÅ›Ä‡**: implementacja mechanizmu _cache_ dodaje kolejnÄ… warstwÄ™ logiki do aplikacji.
- **Trudniejsze debugowanie**: ukrycie obliczeÅ„ za warstwÄ… pamiÄ™ci podrÄ™cznej moÅ¼e czasami utrudniÄ‡ Å›ledzenie bÅ‚Ä™dÃ³w.

Jak w kaÅ¼dym potÄ™Å¼nym zaklÄ™ciu, kluczem jest umiar i Å›wiadomoÅ›Ä‡: **co warto zapamiÄ™taÄ‡, a co trzeba puÅ›ciÄ‡ wolno**.

![Mem w stylu komiksowym, przypominajÄ…cym prace Stana Lee, przedstawiajÄ…cy Dumbledore'a i Harry'ego Pottera stojÄ…cych obok MyÅ›lodsiewni. Dumbledore, z dÅ‚ugÄ… siwÄ… brodÄ… i w okularach, uÅ›miecha siÄ™ z zadowoleniem i wskazuje na MyÅ›lodsiewniÄ™, mÃ³wiÄ…c w dymku: 'Widzisz, Harry? Nie musimy juÅ¼ po raz setny przeliczaÄ‡ 'fib(35)'.' Harry, z potarganymi wÅ‚osami i w okularach, wyglÄ…da na zmÄ™czonego, ale z ulgÄ…, a w dymku myÅ›li mÃ³wi: 'Moja gÅ‚owa juÅ¼ by tego nie zniosÅ‚a!'. W tle widaÄ‡ regaÅ‚y z ksiÄ…Å¼kami i inne przedmioty z gabinetu Dumbledore'a. Wygenerowana przez AI.](./Dumbledore_i_Harry_przy_Myslodsiewni.png)

## Å¹rÃ³dÅ‚a

1. [Wikipedia, "Memoization"](https://en.wikipedia.org/wiki/Memoization)
1. Acar, Umut A., Guy E. Blelloch, and Robert Harper, "Selective Memoization", [ACM SIGPLAN Notices 38.1 (2003): 14-25](http://reports-archive.adm.cs.cmu.edu/anon/anon/usr0/ftp/usr/ftp/2002/CMU-CS-02-194.pdf).
1. [Stack Overflow, "What is the difference between bottom-up and top-down?"](https://stackoverflow.com/questions/6164629/what-is-the-difference-between-bottom-up-and-top-down)
1. [Stack Overflow, "What's the difference between recursion, memoization & dynamic programming?"](https://stackoverflow.com/questions/12133754/whats-the-difference-between-recursion-memoization-dynamic-programming)
